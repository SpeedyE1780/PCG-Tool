<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PCG Engine: pcg::engine::maze_generation Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">PCG Engine<span id="projectnumber">&#160;1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('namespacepcg_1_1engine_1_1maze__generation.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">pcg::engine::maze_generation Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">POD class containing Node x y coordinates.  <a href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1f8150aa32c522a6efb672a73dddd900" id="r_a1f8150aa32c522a6efb672a73dddd900"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f8150aa32c522a6efb672a73dddd900">Directions</a> = std::vector&lt;<a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a>&gt;</td></tr>
<tr class="memdesc:a1f8150aa32c522a6efb672a73dddd900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direction vector alias.  <br /></td></tr>
<tr class="separator:a1f8150aa32c522a6efb672a73dddd900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4530757f2275f202eee6f2232ffecc" id="r_a9b4530757f2275f202eee6f2232ffecc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> = std::vector&lt;<a class="el" href="#a1f8150aa32c522a6efb672a73dddd900">Directions</a>&gt;</td></tr>
<tr class="memdesc:a9b4530757f2275f202eee6f2232ffecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D vector alias  <br /></td></tr>
<tr class="separator:a9b4530757f2275f202eee6f2232ffecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c0ae4fe858736e8e59377d8c963d6b" id="r_a97c0ae4fe858736e8e59377d8c963d6b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> = std::function&lt;void(int, int, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a>)&gt;</td></tr>
<tr class="memdesc:a97c0ae4fe858736e8e59377d8c963d6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used to notify a node was spawned/modified.  <br /></td></tr>
<tr class="separator:a97c0ae4fe858736e8e59377d8c963d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac41e44342eb950ca8ab13e93fa9837ff" id="r_ac41e44342eb950ca8ab13e93fa9837ff"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac41e44342eb950ca8ab13e93fa9837ff">Diagonal</a> { <a class="el" href="#ac41e44342eb950ca8ab13e93fa9837ffadc33066c3993e0d50896e533fd692ce0">NE</a>
, <a class="el" href="#ac41e44342eb950ca8ab13e93fa9837ffa7f39ac71e81132daad44925b3bdfde5a">NW</a>
, <a class="el" href="#ac41e44342eb950ca8ab13e93fa9837ffaf003c44deab679aa2edfaff864c77402">SE</a>
, <a class="el" href="#ac41e44342eb950ca8ab13e93fa9837ffa6f56aa4e2561eb66f17f6d8de8070a77">SW</a>
 }</td></tr>
<tr class="memdesc:ac41e44342eb950ca8ab13e93fa9837ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal algorithm will follow.  <a href="#ac41e44342eb950ca8ab13e93fa9837ff">More...</a><br /></td></tr>
<tr class="separator:ac41e44342eb950ca8ab13e93fa9837ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7497b51edfb792127930eeb274397e1" id="r_ad7497b51edfb792127930eeb274397e1"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7497b51edfb792127930eeb274397e1">SubRegionSize</a> { <br />
&#160;&#160;<a class="el" href="#ad7497b51edfb792127930eeb274397e1af4f1765bae7ac8934dc0c695ee52f4a6">corridors</a> = 0
, <a class="el" href="#ad7497b51edfb792127930eeb274397e1aeb5c1399a871211c7e7ed732d15e3a8b">small</a>
, <a class="el" href="#ad7497b51edfb792127930eeb274397e1a075a3e36a0a52dcbc568c05788e8a713">medium</a>
, <a class="el" href="#ad7497b51edfb792127930eeb274397e1aafacdb0a401ccdf6b48551bbc00e8a74">large</a>
, <br />
&#160;&#160;<a class="el" href="#ad7497b51edfb792127930eeb274397e1ab7cf27ffe6ea83cdcf8af2ef29de9285">huge</a>
<br />
 }</td></tr>
<tr class="memdesc:ad7497b51edfb792127930eeb274397e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">SubRegionSize sets the size minimum size of a subregion.  <a href="#ad7497b51edfb792127930eeb274397e1">More...</a><br /></td></tr>
<tr class="separator:ad7497b51edfb792127930eeb274397e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab135a5e7fc5abd594e83fdae337001" id="r_acab135a5e7fc5abd594e83fdae337001"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a> { <br />
&#160;&#160;<a class="el" href="#acab135a5e7fc5abd594e83fdae337001a334c4a4c42fdb79d7ebc3e73b517e6f8">none</a> = 0
, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001a811882fecd5c7618d7099ebbd39ea254">left</a> = 1 &lt;&lt; 0
, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001a7c4f29407893c334a6cb7a87bf045c0d">right</a> = 1 &lt;&lt; 1
, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001a965dbaac085fc891bfbbd4f9d145bbc8">forward</a> = 1 &lt;&lt; 2
, <br />
&#160;&#160;<a class="el" href="#acab135a5e7fc5abd594e83fdae337001a195fe59b6f103787a914aead0f3db502">backward</a> = 1 &lt;&lt; 3
, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001a13b5bfe96f3e2fe411c9f66f4a582adf">in</a> = 1 &lt;&lt; 4
, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001afcd1f56d8e2475a43275058a7d83cf2f">frontier</a> = 1 &lt;&lt; 5
, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001ab6f795fb591d861967d059bda8c17657">allDirections</a> = left | right | forward | backward
<br />
 }</td></tr>
<tr class="memdesc:acab135a5e7fc5abd594e83fdae337001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flags used to determine if node has an adjacent node.  <a href="#acab135a5e7fc5abd594e83fdae337001">More...</a><br /></td></tr>
<tr class="separator:acab135a5e7fc5abd594e83fdae337001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcf6d5acabba209eaae34746f87ea00" id="r_aedcf6d5acabba209eaae34746f87ea00"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedcf6d5acabba209eaae34746f87ea00">GrowingTreeSelectionMethod</a> { <a class="el" href="#aedcf6d5acabba209eaae34746f87ea00af14b514e6ca0a666ccbf8b7ec839dfb9">oldest</a> = 0
, <a class="el" href="#aedcf6d5acabba209eaae34746f87ea00a4a548addbfb239bbd12f5afe11a4b6dc">middle</a> = 1
, <a class="el" href="#aedcf6d5acabba209eaae34746f87ea00a09286af346951f520509c5702db7625e">newest</a> = 2
, <a class="el" href="#aedcf6d5acabba209eaae34746f87ea00a7ddf32e17a6ac5ce04a8ecbf782ca509">random</a> = 3
 }</td></tr>
<tr class="memdesc:aedcf6d5acabba209eaae34746f87ea00"><td class="mdescLeft">&#160;</td><td class="mdescRight">GrowingTreeSelectionMethod defines how will the next node be chosen.  <a href="#aedcf6d5acabba209eaae34746f87ea00">More...</a><br /></td></tr>
<tr class="separator:aedcf6d5acabba209eaae34746f87ea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a89c2e3f07beadcf6454fab301e03354a" id="r_a89c2e3f07beadcf6454fab301e03354a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89c2e3f07beadcf6454fab301e03354a">operator==</a> (const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;lhs, const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;rhs)</td></tr>
<tr class="separator:a89c2e3f07beadcf6454fab301e03354a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6805f7bef6999139e9a9cc047628bab6" id="r_a6805f7bef6999139e9a9cc047628bab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6805f7bef6999139e9a9cc047628bab6">getAdjacentCoordinates</a> (const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;nodeCoordinates, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a> <a class="el" href="_grid_wave_function_collapse_8cpp.html#a5d3d166e3ca63032f0ac505722106b38">direction</a>)</td></tr>
<tr class="memdesc:a6805f7bef6999139e9a9cc047628bab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get adjacent node x, y coordinates.  <br /></td></tr>
<tr class="separator:a6805f7bef6999139e9a9cc047628bab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91258cadfe5b406ee66af603744ab457" id="r_a91258cadfe5b406ee66af603744ab457"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91258cadfe5b406ee66af603744ab457">getAdjacentCoordinates</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a>, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a> <a class="el" href="_grid_wave_function_collapse_8cpp.html#a5d3d166e3ca63032f0ac505722106b38">direction</a>)</td></tr>
<tr class="memdesc:a91258cadfe5b406ee66af603744ab457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get adjacent node x, y coordinates.  <br /></td></tr>
<tr class="separator:a91258cadfe5b406ee66af603744ab457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7654ed4f119c5c060902e6490dab10c0" id="r_a7654ed4f119c5c060902e6490dab10c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7654ed4f119c5c060902e6490dab10c0">invokeNodeCallback</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a>, const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aff429a5c8aeb722b8907f33ef439466a">grid</a>, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a7654ed4f119c5c060902e6490dab10c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke callback on a single node.  <br /></td></tr>
<tr class="separator:a7654ed4f119c5c060902e6490dab10c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc83c6bcb408602f9206fe55fc88bd6c" id="r_abc83c6bcb408602f9206fe55fc88bd6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc83c6bcb408602f9206fe55fc88bd6c">invokeNodeCallback</a> (const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;node, const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aff429a5c8aeb722b8907f33ef439466a">grid</a>, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:abc83c6bcb408602f9206fe55fc88bd6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke callback on a single node.  <br /></td></tr>
<tr class="separator:abc83c6bcb408602f9206fe55fc88bd6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee229a3e413cea98dac0211831fffc9" id="r_adee229a3e413cea98dac0211831fffc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adee229a3e413cea98dac0211831fffc9">invokeNodePairCallback</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a>, int adjacentX, int adjacentY, const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aff429a5c8aeb722b8907f33ef439466a">grid</a>, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:adee229a3e413cea98dac0211831fffc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke callback on a pair of adjacent node.  <br /></td></tr>
<tr class="separator:adee229a3e413cea98dac0211831fffc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c511851c6a8e41c21385a09626a26f8" id="r_a4c511851c6a8e41c21385a09626a26f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c511851c6a8e41c21385a09626a26f8">invokeNodePairCallback</a> (const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;current, const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;adjacent, const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aff429a5c8aeb722b8907f33ef439466a">grid</a>, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a4c511851c6a8e41c21385a09626a26f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke callback on a pair of adjacent node.  <br /></td></tr>
<tr class="separator:a4c511851c6a8e41c21385a09626a26f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914936e3ef471315978edb84ba8fe227" id="r_a914936e3ef471315978edb84ba8fe227"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a914936e3ef471315978edb84ba8fe227">invokeCallback</a> (const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aff429a5c8aeb722b8907f33ef439466a">grid</a>, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a914936e3ef471315978edb84ba8fe227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops over grid and invoke callback on each node.  <br /></td></tr>
<tr class="separator:a914936e3ef471315978edb84ba8fe227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edacec1fd1cb6eeaaa82b10409a8221" id="r_a8edacec1fd1cb6eeaaa82b10409a8221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8edacec1fd1cb6eeaaa82b10409a8221">generateGrid</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a> defaultValue=<a class="el" href="#acab135a5e7fc5abd594e83fdae337001a334c4a4c42fdb79d7ebc3e73b517e6f8">NodeValue::none</a>)</td></tr>
<tr class="memdesc:a8edacec1fd1cb6eeaaa82b10409a8221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a 2D vector representing the maze's grid.  <br /></td></tr>
<tr class="separator:a8edacec1fd1cb6eeaaa82b10409a8221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8263ed1b1ee3b0aebf5c83056c9434" id="r_a9e8263ed1b1ee3b0aebf5c83056c9434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9e8263ed1b1ee3b0aebf5c83056c9434">generateOpenGrid</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>)</td></tr>
<tr class="memdesc:a9e8263ed1b1ee3b0aebf5c83056c9434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a grid with no walls other than on the edges.  <br /></td></tr>
<tr class="separator:a9e8263ed1b1ee3b0aebf5c83056c9434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2771b8566d8a12d25ca7023617e8d37e" id="r_a2771b8566d8a12d25ca7023617e8d37e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a1f8150aa32c522a6efb672a73dddd900">Directions</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2771b8566d8a12d25ca7023617e8d37e">getDefaultDirections</a> ()</td></tr>
<tr class="memdesc:a2771b8566d8a12d25ca7023617e8d37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get default directions used when generating maze.  <br /></td></tr>
<tr class="separator:a2771b8566d8a12d25ca7023617e8d37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fcc8d4ffeb9f8f9cdabda2c7de777d" id="r_a91fcc8d4ffeb9f8f9cdabda2c7de777d"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91fcc8d4ffeb9f8f9cdabda2c7de777d">isWithinBounds</a> (int <a class="el" href="demos_2gam703-engine_2src_2main_8cpp.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, int size)</td></tr>
<tr class="memdesc:a91fcc8d4ffeb9f8f9cdabda2c7de777d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that value is within index range [0, size[.  <br /></td></tr>
<tr class="separator:a91fcc8d4ffeb9f8f9cdabda2c7de777d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0df3e6cdd2856f4ba8cc51e636d744a" id="r_ac0df3e6cdd2856f4ba8cc51e636d744a"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0df3e6cdd2856f4ba8cc51e636d744a">isWithinGridBounds</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a6150e0515f7202e2fb518f7206ed97dc">x</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a0a2f84ed7838f07779ae24c5a9086d33">y</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>)</td></tr>
<tr class="memdesc:ac0df3e6cdd2856f4ba8cc51e636d744a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that x y are within the Grid's bound x within [0, width[ y within [0, height[.  <br /></td></tr>
<tr class="separator:ac0df3e6cdd2856f4ba8cc51e636d744a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d1a00ac9eed35ca8b39ef7d1e1ec07" id="r_a57d1a00ac9eed35ca8b39ef7d1e1ec07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57d1a00ac9eed35ca8b39ef7d1e1ec07">addAdjacentNodePath</a> (int nodeX, int nodeY, int adjacentNodeX, int adjacentNodeY, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a> <a class="el" href="_grid_wave_function_collapse_8cpp.html#a5d3d166e3ca63032f0ac505722106b38">direction</a>, <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aff429a5c8aeb722b8907f33ef439466a">grid</a>)</td></tr>
<tr class="memdesc:a57d1a00ac9eed35ca8b39ef7d1e1ec07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a path between the node and adjacent node following the given direction.  <br /></td></tr>
<tr class="separator:a57d1a00ac9eed35ca8b39ef7d1e1ec07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6685d6826131385909779f24da5dfa24" id="r_a6685d6826131385909779f24da5dfa24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6685d6826131385909779f24da5dfa24">addAdjacentNodePath</a> (const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;node, const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;adjacentNode, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a> <a class="el" href="_grid_wave_function_collapse_8cpp.html#a5d3d166e3ca63032f0ac505722106b38">direction</a>, <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aff429a5c8aeb722b8907f33ef439466a">grid</a>)</td></tr>
<tr class="memdesc:a6685d6826131385909779f24da5dfa24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a path between the node and adjacent node following the given direction.  <br /></td></tr>
<tr class="separator:a6685d6826131385909779f24da5dfa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eae1ae50a300e402ab421e90c93869" id="r_a67eae1ae50a300e402ab421e90c93869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67eae1ae50a300e402ab421e90c93869">addAdjacentNodeWall</a> (int nodeX, int nodeY, int adjacentNodeX, int adjacentNodeY, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a> <a class="el" href="_grid_wave_function_collapse_8cpp.html#a5d3d166e3ca63032f0ac505722106b38">direction</a>, <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aff429a5c8aeb722b8907f33ef439466a">grid</a>)</td></tr>
<tr class="memdesc:a67eae1ae50a300e402ab421e90c93869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a wall between the node and adjacent node following the given direction.  <br /></td></tr>
<tr class="separator:a67eae1ae50a300e402ab421e90c93869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe61df578ca365e08021b933cfadb349" id="r_abe61df578ca365e08021b933cfadb349"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe61df578ca365e08021b933cfadb349">getRandomStartingNode</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>)</td></tr>
<tr class="memdesc:abe61df578ca365e08021b933cfadb349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a random starting node.  <br /></td></tr>
<tr class="separator:abe61df578ca365e08021b933cfadb349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2daa7728faa6105c237a8e0269b890" id="r_a1c2daa7728faa6105c237a8e0269b890"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c2daa7728faa6105c237a8e0269b890">aldousBroder</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a1c2daa7728faa6105c237a8e0269b890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Aldous Broder Algorithm.  <br /></td></tr>
<tr class="separator:a1c2daa7728faa6105c237a8e0269b890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c720fb7fd4f0cbb353efee1adf7507" id="r_ad9c720fb7fd4f0cbb353efee1adf7507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9c720fb7fd4f0cbb353efee1adf7507">binaryTree</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, <a class="el" href="#ac41e44342eb950ca8ab13e93fa9837ff">Diagonal</a> diagonal, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:ad9c720fb7fd4f0cbb353efee1adf7507"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Binary Tree Algorithm.  <br /></td></tr>
<tr class="separator:ad9c720fb7fd4f0cbb353efee1adf7507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd85876d4464aad0b4dd54542d137e0" id="r_a1dd85876d4464aad0b4dd54542d137e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dd85876d4464aad0b4dd54542d137e0">blobbyDivision</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, <a class="el" href="#ad7497b51edfb792127930eeb274397e1">SubRegionSize</a> regionSize, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a1dd85876d4464aad0b4dd54542d137e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Blobby Division Algorithm.  <br /></td></tr>
<tr class="separator:a1dd85876d4464aad0b4dd54542d137e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50975ccb308b4bdf28554e2b45c658a" id="r_ab50975ccb308b4bdf28554e2b45c658a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab50975ccb308b4bdf28554e2b45c658a">blobbyDivision</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, int regionThreshold, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:ab50975ccb308b4bdf28554e2b45c658a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Blobby Division Algorithm.  <br /></td></tr>
<tr class="separator:ab50975ccb308b4bdf28554e2b45c658a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5bda1a3c41c486e0c1a7f9db2cb9c6" id="r_a1a5bda1a3c41c486e0c1a7f9db2cb9c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a5bda1a3c41c486e0c1a7f9db2cb9c6">eller</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a1a5bda1a3c41c486e0c1a7f9db2cb9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Eller Algorithm.  <br /></td></tr>
<tr class="separator:a1a5bda1a3c41c486e0c1a7f9db2cb9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6bb817d09e2b478e0d511a0e8e2622" id="r_a4a6bb817d09e2b478e0d511a0e8e2622"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a6bb817d09e2b478e0d511a0e8e2622">growingTree</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, <a class="el" href="#aedcf6d5acabba209eaae34746f87ea00">GrowingTreeSelectionMethod</a> method, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a4a6bb817d09e2b478e0d511a0e8e2622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Growing Tree Algorithm.  <br /></td></tr>
<tr class="separator:a4a6bb817d09e2b478e0d511a0e8e2622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17d917c03699da3bde58d85e9ff840c" id="r_aa17d917c03699da3bde58d85e9ff840c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa17d917c03699da3bde58d85e9ff840c">growingTree</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const std::function&lt; int(int)&gt; &amp;nodeSelectionCallback, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:aa17d917c03699da3bde58d85e9ff840c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Growing Tree Algorithm.  <br /></td></tr>
<tr class="separator:aa17d917c03699da3bde58d85e9ff840c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cd2275bee3de885ab4e509fb927ef1" id="r_a46cd2275bee3de885ab4e509fb927ef1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46cd2275bee3de885ab4e509fb927ef1">huntAndKill</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a46cd2275bee3de885ab4e509fb927ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Hunt and Kill Algorithm.  <br /></td></tr>
<tr class="separator:a46cd2275bee3de885ab4e509fb927ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c99f594ce754f523f3e84721643e9b9" id="r_a2c99f594ce754f523f3e84721643e9b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c99f594ce754f523f3e84721643e9b9">kruskal</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a2c99f594ce754f523f3e84721643e9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Kruskal Algorithm.  <br /></td></tr>
<tr class="separator:a2c99f594ce754f523f3e84721643e9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff4f4c62bbe4aea9eae5eee55b2dae9" id="r_aeff4f4c62bbe4aea9eae5eee55b2dae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeff4f4c62bbe4aea9eae5eee55b2dae9">prim</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:aeff4f4c62bbe4aea9eae5eee55b2dae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Prim's Algorithm.  <br /></td></tr>
<tr class="separator:aeff4f4c62bbe4aea9eae5eee55b2dae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299654eb338123da58871fe42da8d2c8" id="r_a299654eb338123da58871fe42da8d2c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a299654eb338123da58871fe42da8d2c8">recursiveBacktracker</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a299654eb338123da58871fe42da8d2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Recursive Backtracker Algorithm.  <br /></td></tr>
<tr class="separator:a299654eb338123da58871fe42da8d2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cbfaa2bb316e67a70fdc395cdb3f67" id="r_a42cbfaa2bb316e67a70fdc395cdb3f67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42cbfaa2bb316e67a70fdc395cdb3f67">recursiveDivision</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a42cbfaa2bb316e67a70fdc395cdb3f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Recursive Division Algorithm.  <br /></td></tr>
<tr class="separator:a42cbfaa2bb316e67a70fdc395cdb3f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd28c41520e2a7d238fd6b053b2250c" id="r_a0dd28c41520e2a7d238fd6b053b2250c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd28c41520e2a7d238fd6b053b2250c">sidewinder</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:a0dd28c41520e2a7d238fd6b053b2250c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Sidewinder Algorithm.  <br /></td></tr>
<tr class="separator:a0dd28c41520e2a7d238fd6b053b2250c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb954a2be7362e7e8d6fd33254ae0e1" id="r_accb954a2be7362e7e8d6fd33254ae0e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accb954a2be7362e7e8d6fd33254ae0e1">wilson</a> (int <a class="el" href="_grid_wave_function_collapse_8cpp.html#a2474a5474cbff19523a51eb1de01cda4">width</a>, int <a class="el" href="_grid_wave_function_collapse_8cpp.html#ad12fc34ce789bce6c8a05d8a17138534">height</a>, bool invokeAfterGeneration, const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;<a class="el" href="_grid_wave_function_collapse_8cpp.html#aa080fcd829f452f640455cd69cf1de22">callback</a>)</td></tr>
<tr class="memdesc:accb954a2be7362e7e8d6fd33254ae0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geneate maze using Wilson Algorithm.  <br /></td></tr>
<tr class="separator:accb954a2be7362e7e8d6fd33254ae0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a1f8150aa32c522a6efb672a73dddd900" name="a1f8150aa32c522a6efb672a73dddd900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8150aa32c522a6efb672a73dddd900">&#9670;&#160;</a></span>Directions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a1f8150aa32c522a6efb672a73dddd900">pcg::engine::maze_generation::Directions</a> = std::vector&lt;<a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Direction vector alias. </p>

</div>
</div>
<a id="a9b4530757f2275f202eee6f2232ffecc" name="a9b4530757f2275f202eee6f2232ffecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4530757f2275f202eee6f2232ffecc">&#9670;&#160;</a></span>Grid</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">pcg::engine::maze_generation::Grid</a> = std::vector&lt;<a class="el" href="#a1f8150aa32c522a6efb672a73dddd900">Directions</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>2D vector alias </p>

</div>
</div>
<a id="a97c0ae4fe858736e8e59377d8c963d6b" name="a97c0ae4fe858736e8e59377d8c963d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c0ae4fe858736e8e59377d8c963d6b">&#9670;&#160;</a></span>MazeCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">pcg::engine::maze_generation::MazeCallback</a> = std::function&lt;void(int, int, <a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback used to notify a node was spawned/modified. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac41e44342eb950ca8ab13e93fa9837ff" name="ac41e44342eb950ca8ab13e93fa9837ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41e44342eb950ca8ab13e93fa9837ff">&#9670;&#160;</a></span>Diagonal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ac41e44342eb950ca8ab13e93fa9837ff">pcg::engine::maze_generation::Diagonal</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Diagonal algorithm will follow. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac41e44342eb950ca8ab13e93fa9837ffadc33066c3993e0d50896e533fd692ce0" name="ac41e44342eb950ca8ab13e93fa9837ffadc33066c3993e0d50896e533fd692ce0"></a>NE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac41e44342eb950ca8ab13e93fa9837ffa7f39ac71e81132daad44925b3bdfde5a" name="ac41e44342eb950ca8ab13e93fa9837ffa7f39ac71e81132daad44925b3bdfde5a"></a>NW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac41e44342eb950ca8ab13e93fa9837ffaf003c44deab679aa2edfaff864c77402" name="ac41e44342eb950ca8ab13e93fa9837ffaf003c44deab679aa2edfaff864c77402"></a>SE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac41e44342eb950ca8ab13e93fa9837ffa6f56aa4e2561eb66f17f6d8de8070a77" name="ac41e44342eb950ca8ab13e93fa9837ffa6f56aa4e2561eb66f17f6d8de8070a77"></a>SW&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aedcf6d5acabba209eaae34746f87ea00" name="aedcf6d5acabba209eaae34746f87ea00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcf6d5acabba209eaae34746f87ea00">&#9670;&#160;</a></span>GrowingTreeSelectionMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#aedcf6d5acabba209eaae34746f87ea00">pcg::engine::maze_generation::GrowingTreeSelectionMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>GrowingTreeSelectionMethod defines how will the next node be chosen. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aedcf6d5acabba209eaae34746f87ea00af14b514e6ca0a666ccbf8b7ec839dfb9" name="aedcf6d5acabba209eaae34746f87ea00af14b514e6ca0a666ccbf8b7ec839dfb9"></a>oldest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aedcf6d5acabba209eaae34746f87ea00a4a548addbfb239bbd12f5afe11a4b6dc" name="aedcf6d5acabba209eaae34746f87ea00a4a548addbfb239bbd12f5afe11a4b6dc"></a>middle&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aedcf6d5acabba209eaae34746f87ea00a09286af346951f520509c5702db7625e" name="aedcf6d5acabba209eaae34746f87ea00a09286af346951f520509c5702db7625e"></a>newest&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aedcf6d5acabba209eaae34746f87ea00a7ddf32e17a6ac5ce04a8ecbf782ca509" name="aedcf6d5acabba209eaae34746f87ea00a7ddf32e17a6ac5ce04a8ecbf782ca509"></a>random&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="acab135a5e7fc5abd594e83fdae337001" name="acab135a5e7fc5abd594e83fdae337001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab135a5e7fc5abd594e83fdae337001">&#9670;&#160;</a></span>NodeValue</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#acab135a5e7fc5abd594e83fdae337001">pcg::engine::maze_generation::NodeValue</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flags used to determine if node has an adjacent node. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acab135a5e7fc5abd594e83fdae337001a334c4a4c42fdb79d7ebc3e73b517e6f8" name="acab135a5e7fc5abd594e83fdae337001a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acab135a5e7fc5abd594e83fdae337001a811882fecd5c7618d7099ebbd39ea254" name="acab135a5e7fc5abd594e83fdae337001a811882fecd5c7618d7099ebbd39ea254"></a>left&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acab135a5e7fc5abd594e83fdae337001a7c4f29407893c334a6cb7a87bf045c0d" name="acab135a5e7fc5abd594e83fdae337001a7c4f29407893c334a6cb7a87bf045c0d"></a>right&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acab135a5e7fc5abd594e83fdae337001a965dbaac085fc891bfbbd4f9d145bbc8" name="acab135a5e7fc5abd594e83fdae337001a965dbaac085fc891bfbbd4f9d145bbc8"></a>forward&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acab135a5e7fc5abd594e83fdae337001a195fe59b6f103787a914aead0f3db502" name="acab135a5e7fc5abd594e83fdae337001a195fe59b6f103787a914aead0f3db502"></a>backward&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acab135a5e7fc5abd594e83fdae337001a13b5bfe96f3e2fe411c9f66f4a582adf" name="acab135a5e7fc5abd594e83fdae337001a13b5bfe96f3e2fe411c9f66f4a582adf"></a>in&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acab135a5e7fc5abd594e83fdae337001afcd1f56d8e2475a43275058a7d83cf2f" name="acab135a5e7fc5abd594e83fdae337001afcd1f56d8e2475a43275058a7d83cf2f"></a>frontier&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="acab135a5e7fc5abd594e83fdae337001ab6f795fb591d861967d059bda8c17657" name="acab135a5e7fc5abd594e83fdae337001ab6f795fb591d861967d059bda8c17657"></a>allDirections&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad7497b51edfb792127930eeb274397e1" name="ad7497b51edfb792127930eeb274397e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7497b51edfb792127930eeb274397e1">&#9670;&#160;</a></span>SubRegionSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#ad7497b51edfb792127930eeb274397e1">pcg::engine::maze_generation::SubRegionSize</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SubRegionSize sets the size minimum size of a subregion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad7497b51edfb792127930eeb274397e1af4f1765bae7ac8934dc0c695ee52f4a6" name="ad7497b51edfb792127930eeb274397e1af4f1765bae7ac8934dc0c695ee52f4a6"></a>corridors&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7497b51edfb792127930eeb274397e1aeb5c1399a871211c7e7ed732d15e3a8b" name="ad7497b51edfb792127930eeb274397e1aeb5c1399a871211c7e7ed732d15e3a8b"></a>small&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7497b51edfb792127930eeb274397e1a075a3e36a0a52dcbc568c05788e8a713" name="ad7497b51edfb792127930eeb274397e1a075a3e36a0a52dcbc568c05788e8a713"></a>medium&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7497b51edfb792127930eeb274397e1aafacdb0a401ccdf6b48551bbc00e8a74" name="ad7497b51edfb792127930eeb274397e1aafacdb0a401ccdf6b48551bbc00e8a74"></a>large&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad7497b51edfb792127930eeb274397e1ab7cf27ffe6ea83cdcf8af2ef29de9285" name="ad7497b51edfb792127930eeb274397e1ab7cf27ffe6ea83cdcf8af2ef29de9285"></a>huge&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6685d6826131385909779f24da5dfa24" name="a6685d6826131385909779f24da5dfa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6685d6826131385909779f24da5dfa24">&#9670;&#160;</a></span>addAdjacentNodePath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::addAdjacentNodePath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacentNode</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a path between the node and adjacent node following the given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Current Node </td></tr>
    <tr><td class="paramname">adjacentNode</td><td>Adjacent Node </td></tr>
    <tr><td class="paramname">direction</td><td>Path direction from node to adjacent </td></tr>
    <tr><td class="paramname">grid</td><td>Grid representing maze </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57d1a00ac9eed35ca8b39ef7d1e1ec07" name="a57d1a00ac9eed35ca8b39ef7d1e1ec07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d1a00ac9eed35ca8b39ef7d1e1ec07">&#9670;&#160;</a></span>addAdjacentNodePath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::addAdjacentNodePath </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nodeX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nodeY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>adjacentNodeX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>adjacentNodeY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a path between the node and adjacent node following the given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeX</td><td>Node X coordinate </td></tr>
    <tr><td class="paramname">nodeY</td><td>Node Y coordinate </td></tr>
    <tr><td class="paramname">adjacentNodeX</td><td>Adjacent Node X coordinate </td></tr>
    <tr><td class="paramname">adjacentNodeY</td><td>Adjacent Node Y coordinate </td></tr>
    <tr><td class="paramname">direction</td><td>Path direction from node to adjacent </td></tr>
    <tr><td class="paramname">grid</td><td>Grid representing maze </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67eae1ae50a300e402ab421e90c93869" name="a67eae1ae50a300e402ab421e90c93869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67eae1ae50a300e402ab421e90c93869">&#9670;&#160;</a></span>addAdjacentNodeWall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::addAdjacentNodeWall </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nodeX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nodeY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>adjacentNodeX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>adjacentNodeY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a wall between the node and adjacent node following the given direction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeX</td><td>Node X coordinate </td></tr>
    <tr><td class="paramname">nodeY</td><td>Node Y coordinate </td></tr>
    <tr><td class="paramname">adjacentNodeX</td><td>Adjacent Node X coordinate </td></tr>
    <tr><td class="paramname">adjacentNodeY</td><td>Adjacent Node Y coordinate </td></tr>
    <tr><td class="paramname">direction</td><td>wall direction from node to adjacent </td></tr>
    <tr><td class="paramname">grid</td><td>Grid representing maze </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c2daa7728faa6105c237a8e0269b890" name="a1c2daa7728faa6105c237a8e0269b890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2daa7728faa6105c237a8e0269b890">&#9670;&#160;</a></span>aldousBroder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::aldousBroder </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Aldous Broder Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9c720fb7fd4f0cbb353efee1adf7507" name="ad9c720fb7fd4f0cbb353efee1adf7507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c720fb7fd4f0cbb353efee1adf7507">&#9670;&#160;</a></span>binaryTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::binaryTree </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ac41e44342eb950ca8ab13e93fa9837ff">Diagonal</a></td>          <td class="paramname"><span class="paramname"><em>diagonal</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Binary Tree Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">diagonal</td><td>Diagonal along which generation is taking place </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab50975ccb308b4bdf28554e2b45c658a" name="ab50975ccb308b4bdf28554e2b45c658a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50975ccb308b4bdf28554e2b45c658a">&#9670;&#160;</a></span>blobbyDivision() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::blobbyDivision </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>regionThreshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Blobby Division Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">regionThreshold</td><td>User defined region threshold </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1dd85876d4464aad0b4dd54542d137e0" name="a1dd85876d4464aad0b4dd54542d137e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd85876d4464aad0b4dd54542d137e0">&#9670;&#160;</a></span>blobbyDivision() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::blobbyDivision </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad7497b51edfb792127930eeb274397e1">SubRegionSize</a></td>          <td class="paramname"><span class="paramname"><em>regionSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Blobby Division Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">regionSize</td><td>Defines region size </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a5bda1a3c41c486e0c1a7f9db2cb9c6" name="a1a5bda1a3c41c486e0c1a7f9db2cb9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a5bda1a3c41c486e0c1a7f9db2cb9c6">&#9670;&#160;</a></span>eller()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::eller </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Eller Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8edacec1fd1cb6eeaaa82b10409a8221" name="a8edacec1fd1cb6eeaaa82b10409a8221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edacec1fd1cb6eeaaa82b10409a8221">&#9670;&#160;</a></span>generateGrid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> pcg::engine::maze_generation::generateGrid </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a></td>          <td class="paramname"><span class="paramname"><em>defaultValue</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#acab135a5e7fc5abd594e83fdae337001a334c4a4c42fdb79d7ebc3e73b517e6f8">NodeValue::none</a></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a 2D vector representing the maze's grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid width </td></tr>
    <tr><td class="paramname">height</td><td>Grid height </td></tr>
    <tr><td class="paramname">defaultValue</td><td>Default value when allocating grid </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2D vector representing the maze's grid </dd></dl>

</div>
</div>
<a id="a9e8263ed1b1ee3b0aebf5c83056c9434" name="a9e8263ed1b1ee3b0aebf5c83056c9434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8263ed1b1ee3b0aebf5c83056c9434">&#9670;&#160;</a></span>generateOpenGrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> pcg::engine::maze_generation::generateOpenGrid </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a grid with no walls other than on the edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid width </td></tr>
    <tr><td class="paramname">height</td><td>Grid height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Grid with walls only on the edges </dd></dl>

</div>
</div>
<a id="a6805f7bef6999139e9a9cc047628bab6" name="a6805f7bef6999139e9a9cc047628bab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6805f7bef6999139e9a9cc047628bab6">&#9670;&#160;</a></span>getAdjacentCoordinates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> pcg::engine::maze_generation::getAdjacentCoordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nodeCoordinates</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get adjacent node x, y coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeCoordinates</td><td>Current node coordinates </td></tr>
    <tr><td class="paramname">direction</td><td>Direction from current node to adjacent node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html" title="POD class containing Node x y coordinates.">NodeCoordinates</a> containing adjacent node x, y coordinate </dd></dl>

</div>
</div>
<a id="a91258cadfe5b406ee66af603744ab457" name="a91258cadfe5b406ee66af603744ab457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91258cadfe5b406ee66af603744ab457">&#9670;&#160;</a></span>getAdjacentCoordinates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; int, int &gt; pcg::engine::maze_generation::getAdjacentCoordinates </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#acab135a5e7fc5abd594e83fdae337001">NodeValue</a></td>          <td class="paramname"><span class="paramname"><em>direction</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get adjacent node x, y coordinates. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Current node x coordinate </td></tr>
    <tr><td class="paramname">y</td><td>Current node y coordinate </td></tr>
    <tr><td class="paramname">direction</td><td>Direction from current node to adjacent node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple containing adjacent node x, y coordinate </dd></dl>

</div>
</div>
<a id="a2771b8566d8a12d25ca7023617e8d37e" name="a2771b8566d8a12d25ca7023617e8d37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2771b8566d8a12d25ca7023617e8d37e">&#9670;&#160;</a></span>getDefaultDirections()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a1f8150aa32c522a6efb672a73dddd900">Directions</a> pcg::engine::maze_generation::getDefaultDirections </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get default directions used when generating maze. </p>
<dl class="section return"><dt>Returns</dt><dd>a vector containing { left, right, forward, backward } </dd></dl>

</div>
</div>
<a id="abe61df578ca365e08021b933cfadb349" name="abe61df578ca365e08021b933cfadb349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe61df578ca365e08021b933cfadb349">&#9670;&#160;</a></span>getRandomStartingNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> pcg::engine::maze_generation::getRandomStartingNode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a random starting node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid width </td></tr>
    <tr><td class="paramname">height</td><td>Grid height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A random starting node </dd></dl>

</div>
</div>
<a id="aa17d917c03699da3bde58d85e9ff840c" name="aa17d917c03699da3bde58d85e9ff840c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17d917c03699da3bde58d85e9ff840c">&#9670;&#160;</a></span>growingTree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::growingTree </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; int(int)&gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>nodeSelectionCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Growing Tree Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">nodeSelectionCallback</td><td>Callback used to select a node from pending growing tree nodes </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a6bb817d09e2b478e0d511a0e8e2622" name="a4a6bb817d09e2b478e0d511a0e8e2622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6bb817d09e2b478e0d511a0e8e2622">&#9670;&#160;</a></span>growingTree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::growingTree </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#aedcf6d5acabba209eaae34746f87ea00">GrowingTreeSelectionMethod</a></td>          <td class="paramname"><span class="paramname"><em>method</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Growing Tree Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">method</td><td>Callback used to select the next node </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46cd2275bee3de885ab4e509fb927ef1" name="a46cd2275bee3de885ab4e509fb927ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cd2275bee3de885ab4e509fb927ef1">&#9670;&#160;</a></span>huntAndKill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::huntAndKill </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Hunt and Kill Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a914936e3ef471315978edb84ba8fe227" name="a914936e3ef471315978edb84ba8fe227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914936e3ef471315978edb84ba8fe227">&#9670;&#160;</a></span>invokeCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::invokeCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loops over grid and invoke callback on each node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Grid representing maze </td></tr>
    <tr><td class="paramname">callback</td><td>User defined callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc83c6bcb408602f9206fe55fc88bd6c" name="abc83c6bcb408602f9206fe55fc88bd6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc83c6bcb408602f9206fe55fc88bd6c">&#9670;&#160;</a></span>invokeNodeCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::invokeNodeCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke callback on a single node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Current node coordinates </td></tr>
    <tr><td class="paramname">grid</td><td>Grid representing maze </td></tr>
    <tr><td class="paramname">callback</td><td>User defined callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7654ed4f119c5c060902e6490dab10c0" name="a7654ed4f119c5c060902e6490dab10c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7654ed4f119c5c060902e6490dab10c0">&#9670;&#160;</a></span>invokeNodeCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::invokeNodeCallback </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke callback on a single node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X coordinate in grid </td></tr>
    <tr><td class="paramname">y</td><td>Y coordinate in grid </td></tr>
    <tr><td class="paramname">grid</td><td>Grid representing maze </td></tr>
    <tr><td class="paramname">callback</td><td>User defined callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c511851c6a8e41c21385a09626a26f8" name="a4c511851c6a8e41c21385a09626a26f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c511851c6a8e41c21385a09626a26f8">&#9670;&#160;</a></span>invokeNodePairCallback() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::invokeNodePairCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>current</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>adjacent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke callback on a pair of adjacent node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">current</td><td>Current node coordinates </td></tr>
    <tr><td class="paramname">adjacent</td><td>Adjacent node coordinates </td></tr>
    <tr><td class="paramname">grid</td><td>Grid representing maze </td></tr>
    <tr><td class="paramname">callback</td><td>User defined callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adee229a3e413cea98dac0211831fffc9" name="adee229a3e413cea98dac0211831fffc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee229a3e413cea98dac0211831fffc9">&#9670;&#160;</a></span>invokeNodePairCallback() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::invokeNodePairCallback </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>adjacentX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>adjacentY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a9b4530757f2275f202eee6f2232ffecc">Grid</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Invoke callback on a pair of adjacent node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X coordinate in grid </td></tr>
    <tr><td class="paramname">y</td><td>Y coordinate in grid </td></tr>
    <tr><td class="paramname">adjacentX</td><td>adjacent X coordinate in grid </td></tr>
    <tr><td class="paramname">adjacentY</td><td>adjacent Y coordinate in grid </td></tr>
    <tr><td class="paramname">grid</td><td>Grid representing maze </td></tr>
    <tr><td class="paramname">callback</td><td>User defined callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a91fcc8d4ffeb9f8f9cdabda2c7de777d" name="a91fcc8d4ffeb9f8f9cdabda2c7de777d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91fcc8d4ffeb9f8f9cdabda2c7de777d">&#9670;&#160;</a></span>isWithinBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcg::engine::maze_generation::isWithinBounds </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check that value is within index range [0, size[. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Index that is being checked </td></tr>
    <tr><td class="paramname">size</td><td>Collection size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True is index is within range [0, size[ </dd></dl>

</div>
</div>
<a id="ac0df3e6cdd2856f4ba8cc51e636d744a" name="ac0df3e6cdd2856f4ba8cc51e636d744a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0df3e6cdd2856f4ba8cc51e636d744a">&#9670;&#160;</a></span>isWithinGridBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcg::engine::maze_generation::isWithinGridBounds </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks that x y are within the Grid's bound x within [0, width[ y within [0, height[. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x index </td></tr>
    <tr><td class="paramname">y</td><td>y index </td></tr>
    <tr><td class="paramname">width</td><td>Grid width </td></tr>
    <tr><td class="paramname">height</td><td>Grid height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if x is within [0, width[ &amp; y is within [0, height[ </dd></dl>

</div>
</div>
<a id="a2c99f594ce754f523f3e84721643e9b9" name="a2c99f594ce754f523f3e84721643e9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c99f594ce754f523f3e84721643e9b9">&#9670;&#160;</a></span>kruskal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::kruskal </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Kruskal Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89c2e3f07beadcf6454fab301e03354a" name="a89c2e3f07beadcf6454fab301e03354a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c2e3f07beadcf6454fab301e03354a">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool pcg::engine::maze_generation::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structpcg_1_1engine_1_1maze__generation_1_1_node_coordinates.html">NodeCoordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeff4f4c62bbe4aea9eae5eee55b2dae9" name="aeff4f4c62bbe4aea9eae5eee55b2dae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff4f4c62bbe4aea9eae5eee55b2dae9">&#9670;&#160;</a></span>prim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::prim </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Prim's Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a299654eb338123da58871fe42da8d2c8" name="a299654eb338123da58871fe42da8d2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299654eb338123da58871fe42da8d2c8">&#9670;&#160;</a></span>recursiveBacktracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::recursiveBacktracker </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Recursive Backtracker Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42cbfaa2bb316e67a70fdc395cdb3f67" name="a42cbfaa2bb316e67a70fdc395cdb3f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cbfaa2bb316e67a70fdc395cdb3f67">&#9670;&#160;</a></span>recursiveDivision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::recursiveDivision </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Recursive Division Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dd28c41520e2a7d238fd6b053b2250c" name="a0dd28c41520e2a7d238fd6b053b2250c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd28c41520e2a7d238fd6b053b2250c">&#9670;&#160;</a></span>sidewinder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::sidewinder </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Sidewinder Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="accb954a2be7362e7e8d6fd33254ae0e1" name="accb954a2be7362e7e8d6fd33254ae0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb954a2be7362e7e8d6fd33254ae0e1">&#9670;&#160;</a></span>wilson()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcg::engine::maze_generation::wilson </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>invokeAfterGeneration</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a97c0ae4fe858736e8e59377d8c963d6b">MazeCallback</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>callback</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Geneate maze using Wilson Algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>Grid Width </td></tr>
    <tr><td class="paramname">height</td><td>Grid Height </td></tr>
    <tr><td class="paramname">invokeAfterGeneration</td><td>If true callback will only be called after all nodes are generated </td></tr>
    <tr><td class="paramname">callback</td><td>Callback when a node is generated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacepcg.html">pcg</a></li><li class="navelem"><a class="el" href="namespacepcg_1_1engine.html">engine</a></li><li class="navelem"><a class="el" href="namespacepcg_1_1engine_1_1maze__generation.html">maze_generation</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
